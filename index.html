<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pigeon Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }

        .game-container {
            background: linear-gradient(145deg, #1e1e2e, #2a2a3e);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 15px;
        }

        .score, .high-score {
            font-size: 1.3rem;
            font-weight: 600;
            color: #e0e0e0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .high-score {
            color: #ffd700;
        }

        canvas {
            display: block;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4),
                        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .controls {
            margin-top: 20px;
            text-align: center;
        }

        .btn {
            background: linear-gradient(135deg, #e94560 0%, #c23a51 100%);
            color: white;
            border: none;
            padding: 14px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(233, 69, 96, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(233, 69, 96, 0.5);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .instructions {
            margin-top: 18px;
            text-align: center;
            color: #888;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .instructions strong {
            color: #e94560;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 20, 35, 0.95), rgba(30, 30, 50, 0.95));
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .game-over h2 {
            margin-bottom: 15px;
            font-size: 2rem;
            color: #e94560;
        }

        .game-over p {
            margin-bottom: 25px;
            font-size: 1.2rem;
            color: #ccc;
        }

        .jump-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: #4ade80;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .jump-indicator.cooldown {
            color: #888;
        }

        .speed-boost {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #1a1a1a;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            display: none;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: translateX(-50%) scale(1); }
            to { transform: translateX(-50%) scale(1.05); }
        }

        /* Mobile touch controls */
        .touch-controls {
            display: none;
            margin-top: 15px;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            touch-action: none;
        }

        .dpad-container {
            position: relative;
            width: 140px;
            height: 140px;
        }

        .dpad-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #fff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .dpad-btn:active, .dpad-btn.active {
            background: linear-gradient(145deg, #4a4a7a, #3a3a6a);
            transform: scale(0.95);
        }

        .dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        .dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

        .dpad-up:active, .dpad-up.active { transform: translateX(-50%) scale(0.95); }
        .dpad-down:active, .dpad-down.active { transform: translateX(-50%) scale(0.95); }
        .dpad-left:active, .dpad-left.active { transform: translateY(-50%) scale(0.95); }
        .dpad-right:active, .dpad-right.active { transform: translateY(-50%) scale(0.95); }

        .jump-btn {
            width: 90px;
            height: 90px;
            background: linear-gradient(145deg, #e94560, #c23a51);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.4);
        }

        .jump-btn:active, .jump-btn.active {
            background: linear-gradient(145deg, #c23a51, #a02040);
            transform: scale(0.95);
        }

        .jump-btn.cooldown {
            background: linear-gradient(145deg, #555, #444);
            box-shadow: none;
        }

        /* Mobile responsive styles */
        @media (max-width: 700px) {
            body {
                padding: 10px;
                align-items: flex-start;
            }

            .game-container {
                padding: 15px;
                border-radius: 15px;
                width: 100%;
                max-width: 100%;
            }

            .header {
                margin-bottom: 10px;
                padding: 0 5px;
            }

            .score, .high-score {
                font-size: 1rem;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }

            .controls {
                margin-top: 10px;
            }

            .btn {
                padding: 12px 30px;
                font-size: 1rem;
            }

            .instructions {
                display: none;
            }

            .touch-controls {
                display: flex;
            }

            .jump-indicator {
                font-size: 0.75rem;
                padding: 4px 10px;
            }

            .game-over {
                padding: 25px 35px;
            }

            .game-over h2 {
                font-size: 1.5rem;
            }

            .game-over p {
                font-size: 1rem;
            }
        }

        @media (max-width: 400px) {
            .dpad-container {
                width: 120px;
                height: 120px;
            }

            .dpad-btn {
                width: 42px;
                height: 42px;
                font-size: 20px;
            }

            .jump-btn {
                width: 75px;
                height: 75px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="high-score">Best: <span id="highScore">0</span></div>
        </div>
        <div style="position: relative;">
            <canvas id="gameCanvas" width="600" height="500"></canvas>
            <div class="game-over" id="gameOver">
                <h2>Game Over!</h2>
                <p>Score: <span id="finalScore">0</span></p>
                <button class="btn" onclick="Game.start()">Play Again</button>
            </div>
            <div class="jump-indicator" id="jumpIndicator">SPACE to Jump</div>
            <div class="speed-boost" id="speedBoost">SPEED BOOST! 20s</div>
        </div>
        <div class="controls">
            <button class="btn" id="startBtn" onclick="Game.start()">Start Game</button>
        </div>
        <div class="instructions">
            <strong>SPACE</strong> to start/restart |
            <strong>Arrow Keys</strong> or <strong>WASD</strong> to move |
            <strong>SPACE</strong> to jump<br>
            Collect breadcrumbs, avoid cats, use trees for safety!
        </div>
        <div class="touch-controls" id="touchControls">
            <div class="dpad-container">
                <button class="dpad-btn dpad-up" data-dir="up">▲</button>
                <button class="dpad-btn dpad-down" data-dir="down">▼</button>
                <button class="dpad-btn dpad-left" data-dir="left">◀</button>
                <button class="dpad-btn dpad-right" data-dir="right">▶</button>
            </div>
            <button class="jump-btn" id="jumpBtn">JUMP</button>
        </div>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            CANVAS_WIDTH: 600,
            CANVAS_HEIGHT: 500,
            TILE_SIZE: 40,
            PIGEON_SPEED: 3,
            CAT_BASE_SPEED: 1.5,
            JUMP_DURATION: 400,
            JUMP_COOLDOWN: 600,
            SPAWN_RADIUS: 400,      // Distance from pigeon to spawn new content
            DESPAWN_RADIUS: 600,    // Distance from pigeon to remove old content
            TREE_DENSITY: 0.02,     // Chance of tree per tile
            DEBUG: false
        };

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function hash(x, y, seed = 0) {
            const h = Math.sin(x * 12.9898 + y * 78.233 + seed * 43.758) * 43758.5453;
            return h - Math.floor(h);
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // ============================================
        // WORLD GENERATION
        // ============================================
        const World = {
            trees: new Map(),       // key: "x,y" -> tree object
            groundCache: new Map(), // key: "x,y" -> ground tile data

            getTreeKey(x, y) {
                // Round to tile grid
                const tx = Math.floor(x / CONFIG.TILE_SIZE);
                const ty = Math.floor(y / CONFIG.TILE_SIZE);
                return `${tx},${ty}`;
            },

            hasTreeAt(worldX, worldY) {
                const tx = Math.floor(worldX / CONFIG.TILE_SIZE);
                const ty = Math.floor(worldY / CONFIG.TILE_SIZE);
                const key = `${tx},${ty}`;

                if (this.trees.has(key)) {
                    return this.trees.get(key);
                }

                // Deterministically decide if there's a tree here
                const h = hash(tx, ty, 42);
                if (h < CONFIG.TREE_DENSITY) {
                    const tree = {
                        x: tx * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,
                        y: ty * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,
                        radius: 25,
                        climbingCat: null
                    };
                    this.trees.set(key, tree);
                    return tree;
                }

                this.trees.set(key, null);
                return null;
            },

            getGroundTile(tx, ty) {
                const key = `${tx},${ty}`;
                if (this.groundCache.has(key)) {
                    return this.groundCache.get(key);
                }

                const h1 = hash(tx, ty, 1);
                const h2 = hash(tx, ty, 2);
                const h3 = hash(tx, ty, 3);

                let type = 'grass';
                if (h1 > 0.92) type = 'dirt';
                else if (h1 > 0.85) type = 'darkgrass';

                const tile = {
                    type,
                    variation: h2 * 20 - 10,
                    hasFlower: h3 > 0.95,
                    hasRock: h3 < 0.03,
                    hasTuft: h2 > 0.9
                };

                this.groundCache.set(key, tile);
                return tile;
            },

            getTreesInView(camX, camY, width, height) {
                const result = [];
                const margin = CONFIG.TILE_SIZE * 2;
                const startX = Math.floor((camX - margin) / CONFIG.TILE_SIZE);
                const startY = Math.floor((camY - margin) / CONFIG.TILE_SIZE);
                const endX = Math.ceil((camX + width + margin) / CONFIG.TILE_SIZE);
                const endY = Math.ceil((camY + height + margin) / CONFIG.TILE_SIZE);

                for (let ty = startY; ty <= endY; ty++) {
                    for (let tx = startX; tx <= endX; tx++) {
                        const tree = this.hasTreeAt(tx * CONFIG.TILE_SIZE, ty * CONFIG.TILE_SIZE);
                        if (tree) {
                            result.push(tree);
                        }
                    }
                }
                return result;
            },

            getNearestTree(worldX, worldY, maxDist) {
                let nearest = null;
                let nearestDist = maxDist;

                const searchRadius = Math.ceil(maxDist / CONFIG.TILE_SIZE) + 1;
                const tx = Math.floor(worldX / CONFIG.TILE_SIZE);
                const ty = Math.floor(worldY / CONFIG.TILE_SIZE);

                for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        const tree = this.hasTreeAt((tx + dx) * CONFIG.TILE_SIZE, (ty + dy) * CONFIG.TILE_SIZE);
                        if (tree) {
                            const dist = distance(worldX, worldY, tree.x, tree.y);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = tree;
                            }
                        }
                    }
                }
                return nearest;
            },

            reset() {
                this.trees.clear();
                this.groundCache.clear();
            }
        };

        // ============================================
        // RENDERER
        // ============================================
        const Renderer = {
            ctx: null,
            canvas: null,

            init(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            },

            clear() {
                this.ctx.fillStyle = '#4a7c3f';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            },

            worldToScreen(worldX, worldY, camX, camY) {
                return {
                    x: worldX - camX,
                    y: worldY - camY
                };
            },

            drawGround(camX, camY) {
                const startX = Math.floor(camX / CONFIG.TILE_SIZE) - 1;
                const startY = Math.floor(camY / CONFIG.TILE_SIZE) - 1;
                const tilesX = Math.ceil(this.canvas.width / CONFIG.TILE_SIZE) + 2;
                const tilesY = Math.ceil(this.canvas.height / CONFIG.TILE_SIZE) + 2;

                for (let ty = startY; ty < startY + tilesY; ty++) {
                    for (let tx = startX; tx < startX + tilesX; tx++) {
                        const tile = World.getGroundTile(tx, ty);
                        const screenX = tx * CONFIG.TILE_SIZE - camX;
                        const screenY = ty * CONFIG.TILE_SIZE - camY;

                        // Base color
                        let r, g, b;
                        switch (tile.type) {
                            case 'dirt':
                                r = 139 + tile.variation;
                                g = 115 + tile.variation * 0.7;
                                b = 85 + tile.variation * 0.5;
                                break;
                            case 'darkgrass':
                                r = 55 + tile.variation * 0.5;
                                g = 95 + tile.variation;
                                b = 45 + tile.variation * 0.3;
                                break;
                            default: // grass
                                r = 74 + tile.variation * 0.6;
                                g = 124 + tile.variation;
                                b = 63 + tile.variation * 0.4;
                        }

                        this.ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                        this.ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE + 1, CONFIG.TILE_SIZE + 1);

                        // Decorations
                        if (tile.hasFlower) {
                            this.drawFlower(screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);
                        }
                        if (tile.hasRock) {
                            this.drawRock(screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);
                        }
                        if (tile.hasTuft) {
                            this.drawGrassTuft(screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);
                        }
                    }
                }
            },

            drawFlower(x, y) {
                const colors = ['#FFE4B5', '#FFB6C1', '#E6E6FA', '#FFFACD'];
                this.ctx.fillStyle = colors[Math.floor(hash(x, y, 10) * colors.length)];
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x + Math.cos(angle) * 4, y + Math.sin(angle) * 4, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.fillStyle = '#FFD700';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawRock(x, y) {
                this.ctx.fillStyle = '#888';
                this.ctx.beginPath();
                this.ctx.ellipse(x, y, 8, 6, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#aaa';
                this.ctx.beginPath();
                this.ctx.ellipse(x - 2, y - 2, 3, 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawGrassTuft(x, y) {
                this.ctx.strokeStyle = '#2d5a1e';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const angle = -Math.PI / 2 + (i - 1) * 0.3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y);
                    this.ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
                    this.ctx.stroke();
                }
            },

            drawTree(screenX, screenY, hasPigeon = false, hasCat = false) {
                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(screenX, screenY + 5, 30, 15, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Trunk
                this.ctx.fillStyle = '#5D4037';
                this.ctx.fillRect(screenX - 8, screenY - 50, 16, 55);

                // Foliage
                const foliageColors = ['#2E7D32', '#388E3C', '#43A047'];
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = foliageColors[i];
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY - 50 - i * 15, 30 - i * 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Pigeon on tree
                if (hasPigeon) {
                    this.ctx.fillStyle = '#708090';
                    this.ctx.beginPath();
                    this.ctx.ellipse(screenX, screenY - 85, 12, 8, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#607080';
                    this.ctx.beginPath();
                    this.ctx.arc(screenX + 8, screenY - 90, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Cat climbing
                if (hasCat) {
                    this.ctx.fillStyle = '#E85D04';
                    this.ctx.beginPath();
                    this.ctx.ellipse(screenX + 12, screenY - 30, 10, 8, 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(screenX + 18, screenY - 35, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            },

            drawPigeon(screenX, screenY, direction = 1, isJumping = false) {
                const jumpOffset = isJumping ? -15 : 0;
                const y = screenY + jumpOffset;

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(screenX, screenY + 5, isJumping ? 12 : 18, isJumping ? 6 : 9, 0, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.save();
                this.ctx.translate(screenX, y);
                this.ctx.scale(direction, 1);

                // Body
                this.ctx.fillStyle = '#708090';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, 20, 14, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Wing
                this.ctx.fillStyle = '#5A6A7A';
                this.ctx.beginPath();
                this.ctx.ellipse(-3, 2, 12, 8, -0.2, 0, Math.PI * 2);
                this.ctx.fill();

                // Neck shimmer
                this.ctx.fillStyle = '#8B5CF6';
                this.ctx.beginPath();
                this.ctx.ellipse(8, -5, 8, 6, 0.3, 0, Math.PI * 2);
                this.ctx.fill();

                // Head
                this.ctx.fillStyle = '#607080';
                this.ctx.beginPath();
                this.ctx.arc(14, -10, 10, 0, Math.PI * 2);
                this.ctx.fill();

                // Eye
                this.ctx.fillStyle = '#FF6B35';
                this.ctx.beginPath();
                this.ctx.arc(18, -12, 4, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#FFF';
                this.ctx.beginPath();
                this.ctx.arc(18, -12, 2.5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(19, -12, 1.5, 0, Math.PI * 2);
                this.ctx.fill();

                // Beak
                this.ctx.fillStyle = '#FFB347';
                this.ctx.beginPath();
                this.ctx.moveTo(22, -10);
                this.ctx.lineTo(30, -8);
                this.ctx.lineTo(22, -6);
                this.ctx.closePath();
                this.ctx.fill();

                // Tail
                this.ctx.fillStyle = '#4A5A6A';
                this.ctx.beginPath();
                this.ctx.moveTo(-18, 0);
                this.ctx.lineTo(-28, 5);
                this.ctx.lineTo(-18, 8);
                this.ctx.closePath();
                this.ctx.fill();

                this.ctx.restore();
            },

            drawCat(screenX, screenY, direction = 1) {
                this.ctx.save();
                this.ctx.translate(screenX, screenY);
                this.ctx.scale(direction, 1);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 15, 22, 10, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Tail
                this.ctx.strokeStyle = '#E85D04';
                this.ctx.lineWidth = 5;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(-20, 0);
                const tailWave = Math.sin(performance.now() / 200) * 5;
                this.ctx.quadraticCurveTo(-30, -10 + tailWave, -25, -20 + tailWave);
                this.ctx.stroke();

                // Body
                this.ctx.fillStyle = '#E85D04';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, 24, 16, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Stripes
                this.ctx.strokeStyle = '#C44D04';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-8 + i * 8, -12);
                    this.ctx.lineTo(-8 + i * 8, 12);
                    this.ctx.stroke();
                }

                // Head
                this.ctx.fillStyle = '#E85D04';
                this.ctx.beginPath();
                this.ctx.arc(18, -5, 14, 0, Math.PI * 2);
                this.ctx.fill();

                // Ears
                this.ctx.beginPath();
                this.ctx.moveTo(10, -15);
                this.ctx.lineTo(14, -28);
                this.ctx.lineTo(20, -17);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.moveTo(22, -15);
                this.ctx.lineTo(22, -28);
                this.ctx.lineTo(28, -17);
                this.ctx.closePath();
                this.ctx.fill();

                // Inner ears
                this.ctx.fillStyle = '#FFB6C1';
                this.ctx.beginPath();
                this.ctx.moveTo(13, -17);
                this.ctx.lineTo(15, -24);
                this.ctx.lineTo(18, -18);
                this.ctx.closePath();
                this.ctx.fill();

                // Eyes
                this.ctx.fillStyle = '#90EE90';
                this.ctx.beginPath();
                this.ctx.ellipse(14, -6, 4, 5, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.ellipse(24, -6, 4, 5, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Pupils
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.ellipse(14, -6, 1.5, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.ellipse(24, -6, 1.5, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Nose
                this.ctx.fillStyle = '#FF69B4';
                this.ctx.beginPath();
                this.ctx.moveTo(19, 0);
                this.ctx.lineTo(16, 4);
                this.ctx.lineTo(22, 4);
                this.ctx.closePath();
                this.ctx.fill();

                // Whiskers
                this.ctx.strokeStyle = '#FFF';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(12, 2 + i * 3);
                    this.ctx.lineTo(-5, i * 3);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(26, 2 + i * 3);
                    this.ctx.lineTo(40, i * 3);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            },

            drawBreadcrumb(screenX, screenY) {
                const bob = Math.sin(performance.now() / 300 + screenX * 0.1) * 3;
                const y = screenY + bob;

                // Glow
                this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(screenX, y, 15, 0, Math.PI * 2);
                this.ctx.fill();

                // Crumb
                const grad = this.ctx.createRadialGradient(screenX - 2, y - 2, 0, screenX, y, 8);
                grad.addColorStop(0, '#FFF8DC');
                grad.addColorStop(0.5, '#DEB887');
                grad.addColorStop(1, '#B8860B');
                this.ctx.fillStyle = grad;
                this.ctx.beginPath();
                this.ctx.arc(screenX, y, 8, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawChest(screenX, screenY) {
                const bob = Math.sin(performance.now() / 400) * 2;
                const y = screenY + bob;

                // Glow effect
                this.ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(screenX, y, 30, 0, Math.PI * 2);
                this.ctx.fill();

                // Chest body
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(screenX - 18, y - 10, 36, 24);

                // Chest lid
                this.ctx.fillStyle = '#A0522D';
                this.ctx.beginPath();
                this.ctx.moveTo(screenX - 20, y - 10);
                this.ctx.lineTo(screenX - 18, y - 20);
                this.ctx.lineTo(screenX + 18, y - 20);
                this.ctx.lineTo(screenX + 20, y - 10);
                this.ctx.closePath();
                this.ctx.fill();

                // Chest trim
                this.ctx.fillStyle = '#FFD700';
                this.ctx.fillRect(screenX - 20, y - 12, 40, 4);
                this.ctx.fillRect(screenX - 4, y - 8, 8, 12);

                // Lock/clasp
                this.ctx.fillStyle = '#DAA520';
                this.ctx.beginPath();
                this.ctx.arc(screenX, y - 2, 4, 0, Math.PI * 2);
                this.ctx.fill();

                // Bread icon on top
                this.ctx.fillStyle = '#F4A460';
                this.ctx.beginPath();
                this.ctx.ellipse(screenX, y - 25, 10, 6, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#DEB887';
                this.ctx.beginPath();
                this.ctx.ellipse(screenX, y - 27, 7, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
        };

        // ============================================
        // GAME ENGINE
        // ============================================
        const Game = {
            running: false,
            score: 0,
            highScore: 0,
            pigeon: null,
            cats: [],
            breadcrumbs: [],
            chests: [],
            keys: {},
            lastCatSpawn: 0,
            lastBreadcrumbSpawn: 0,
            lastChestSpawn: 0,

            init() {
                const canvas = document.getElementById('gameCanvas');
                Renderer.init(canvas);

                this.highScore = parseInt(localStorage.getItem('pigeonHighScore')) || 0;
                document.getElementById('highScore').textContent = this.highScore;

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
                        e.preventDefault();
                    }
                    if (e.key === ' ') {
                        if (this.running) {
                            this.tryJump();
                        } else {
                            this.start();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                this.initTouchControls();
                this.renderStartScreen();
            },

            initTouchControls() {
                const dpadBtns = document.querySelectorAll('.dpad-btn');
                const jumpBtn = document.getElementById('jumpBtn');

                const dirKeyMap = {
                    'up': 'w',
                    'down': 's',
                    'left': 'a',
                    'right': 'd'
                };

                dpadBtns.forEach(btn => {
                    const dir = btn.dataset.dir;
                    const key = dirKeyMap[dir];

                    const startHandler = (e) => {
                        e.preventDefault();
                        this.keys[key] = true;
                        btn.classList.add('active');
                    };

                    const endHandler = (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                        btn.classList.remove('active');
                    };

                    btn.addEventListener('touchstart', startHandler, { passive: false });
                    btn.addEventListener('touchend', endHandler, { passive: false });
                    btn.addEventListener('touchcancel', endHandler, { passive: false });
                    btn.addEventListener('mousedown', startHandler);
                    btn.addEventListener('mouseup', endHandler);
                    btn.addEventListener('mouseleave', endHandler);
                });

                const jumpStart = (e) => {
                    e.preventDefault();
                    if (this.running) {
                        this.tryJump();
                    } else {
                        this.start();
                    }
                    jumpBtn.classList.add('active');
                };

                const jumpEnd = (e) => {
                    e.preventDefault();
                    jumpBtn.classList.remove('active');
                };

                jumpBtn.addEventListener('touchstart', jumpStart, { passive: false });
                jumpBtn.addEventListener('touchend', jumpEnd, { passive: false });
                jumpBtn.addEventListener('touchcancel', jumpEnd, { passive: false });
                jumpBtn.addEventListener('mousedown', jumpStart);
                jumpBtn.addEventListener('mouseup', jumpEnd);
                jumpBtn.addEventListener('mouseleave', jumpEnd);

                const gameContainer = document.querySelector('.game-container');
                gameContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
            },

            renderStartScreen() {
                Renderer.clear();
                Renderer.drawPigeon(300, 250, 1, false);
                Renderer.drawTree(150, 200);
                Renderer.drawTree(450, 300);
                Renderer.drawBreadcrumb(350, 180);
                Renderer.drawCat(200, 350, 1);

                Renderer.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                Renderer.ctx.font = 'bold 28px Segoe UI';
                Renderer.ctx.textAlign = 'center';
                Renderer.ctx.fillText('Press Start to Play!', 300, 80);
            },

            start() {
                World.reset();

                this.pigeon = {
                    x: 0,
                    y: 0,
                    speed: CONFIG.PIGEON_SPEED,
                    direction: 1,
                    isJumping: false,
                    jumpStartTime: 0,
                    lastJumpTime: 0,
                    onTree: null,
                    speedBoostEnd: 0
                };

                this.cats = [];
                this.breadcrumbs = [];
                this.chests = [];
                this.score = 0;
                this.lastCatSpawn = 0;
                this.lastBreadcrumbSpawn = 0;
                this.lastChestSpawn = 0;

                document.getElementById('score').textContent = this.score;
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('startBtn').textContent = 'Restart';
                document.getElementById('jumpIndicator').style.display = 'block';

                // Spawn initial breadcrumbs
                for (let i = 0; i < 8; i++) {
                    this.spawnBreadcrumb();
                }

                this.running = true;
                requestAnimationFrame((t) => this.loop(t));
            },

            tryJump() {
                const now = performance.now();
                if (this.pigeon.isJumping) return;
                if (now - this.pigeon.lastJumpTime < CONFIG.JUMP_COOLDOWN) return;

                // Jump off tree
                if (this.pigeon.onTree) {
                    const tree = this.pigeon.onTree;
                    this.pigeon.onTree = null;
                    this.pigeon.isJumping = true;
                    this.pigeon.jumpStartTime = now;
                    this.pigeon.lastJumpTime = now;
                    // Move away from tree
                    this.pigeon.x = tree.x + 40 * this.pigeon.direction;
                    return;
                }

                // Check if near a tree to jump onto
                const nearTree = World.getNearestTree(this.pigeon.x, this.pigeon.y, 50);
                if (nearTree) {
                    this.pigeon.onTree = nearTree;
                    this.pigeon.x = nearTree.x;
                    this.pigeon.y = nearTree.y;
                    this.pigeon.lastJumpTime = now;
                    return;
                }

                // Regular jump
                this.pigeon.isJumping = true;
                this.pigeon.jumpStartTime = now;
                this.pigeon.lastJumpTime = now;
            },

            spawnBreadcrumb() {
                const angle = Math.random() * Math.PI * 2;
                const dist = 100 + Math.random() * 250;
                const x = this.pigeon.x + Math.cos(angle) * dist;
                const y = this.pigeon.y + Math.sin(angle) * dist;

                // Don't spawn on trees
                const nearTree = World.getNearestTree(x, y, 30);
                if (!nearTree) {
                    this.breadcrumbs.push({ x, y });
                }
            },

            spawnCat() {
                const angle = Math.random() * Math.PI * 2;
                const dist = CONFIG.SPAWN_RADIUS;
                const x = this.pigeon.x + Math.cos(angle) * dist;
                const y = this.pigeon.y + Math.sin(angle) * dist;

                // Move toward pigeon
                const dx = this.pigeon.x - x;
                const dy = this.pigeon.y - y;
                const len = Math.sqrt(dx * dx + dy * dy);

                this.cats.push({
                    x,
                    y,
                    dirX: dx / len,
                    dirY: dy / len,
                    speed: CONFIG.CAT_BASE_SPEED + this.score / 500,
                    direction: dx > 0 ? 1 : -1,
                    climbingTree: null,
                    climbProgress: 0
                });
            },

            spawnChest() {
                const angle = Math.random() * Math.PI * 2;
                const dist = 150 + Math.random() * 200;
                const x = this.pigeon.x + Math.cos(angle) * dist;
                const y = this.pigeon.y + Math.sin(angle) * dist;

                // Don't spawn on trees
                const nearTree = World.getNearestTree(x, y, 40);
                if (!nearTree) {
                    this.chests.push({ x, y });
                }
            },

            update(timestamp) {
                // Update jump state
                if (this.pigeon.isJumping) {
                    if (timestamp - this.pigeon.jumpStartTime > CONFIG.JUMP_DURATION) {
                        this.pigeon.isJumping = false;
                    }
                }

                // Update UI
                const jumpIndicator = document.getElementById('jumpIndicator');
                const jumpBtn = document.getElementById('jumpBtn');
                const canJump = timestamp - this.pigeon.lastJumpTime >= CONFIG.JUMP_COOLDOWN;

                if (this.pigeon.isJumping) {
                    jumpIndicator.textContent = 'JUMPING!';
                    jumpIndicator.className = 'jump-indicator';
                    jumpBtn.textContent = 'JUMP!';
                    jumpBtn.classList.remove('cooldown');
                } else if (this.pigeon.onTree) {
                    jumpIndicator.textContent = 'SPACE to Jump Off';
                    jumpIndicator.className = 'jump-indicator';
                    jumpBtn.textContent = 'JUMP OFF';
                    jumpBtn.classList.remove('cooldown');
                } else {
                    jumpIndicator.textContent = canJump ? 'SPACE to Jump' : 'Cooldown...';
                    jumpIndicator.className = 'jump-indicator' + (canJump ? '' : ' cooldown');
                    jumpBtn.textContent = canJump ? 'JUMP' : '...';
                    jumpBtn.classList.toggle('cooldown', !canJump);
                }

                // Handle pigeon movement
                if (!this.pigeon.onTree) {
                    let dx = 0, dy = 0;

                    if (this.keys['arrowup'] || this.keys['w']) dy -= 1;
                    if (this.keys['arrowdown'] || this.keys['s']) dy += 1;
                    if (this.keys['arrowleft'] || this.keys['a']) dx -= 1;
                    if (this.keys['arrowright'] || this.keys['d']) dx += 1;

                    // Normalize diagonal movement
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                    }

                    // Check tree collision
                    const newX = this.pigeon.x + dx * this.pigeon.speed;
                    const newY = this.pigeon.y + dy * this.pigeon.speed;

                    let blocked = false;
                    if (!this.pigeon.isJumping) {
                        const nearTree = World.getNearestTree(newX, newY, 25);
                        if (nearTree) {
                            blocked = true;
                        }
                    }

                    if (!blocked) {
                        this.pigeon.x = newX;
                        this.pigeon.y = newY;
                    }

                    if (dx > 0) this.pigeon.direction = 1;
                    else if (dx < 0) this.pigeon.direction = -1;
                }

                // Spawn breadcrumbs
                if (timestamp - this.lastBreadcrumbSpawn > 2000) {
                    this.spawnBreadcrumb();
                    this.lastBreadcrumbSpawn = timestamp;
                }

                // Spawn cats
                const catInterval = Math.max(3000 - this.score * 20, 1500);
                if (timestamp - this.lastCatSpawn > catInterval) {
                    this.spawnCat();
                    this.lastCatSpawn = timestamp;
                }

                // Spawn chests (rare)
                if (timestamp - this.lastChestSpawn > 15000 && this.chests.length < 2) {
                    this.spawnChest();
                    this.lastChestSpawn = timestamp;
                }

                // Update speed boost
                const speedBoostEl = document.getElementById('speedBoost');
                const isBoosted = timestamp < this.pigeon.speedBoostEnd;
                if (isBoosted) {
                    const remaining = Math.ceil((this.pigeon.speedBoostEnd - timestamp) / 1000);
                    speedBoostEl.textContent = `SPEED BOOST! ${remaining}s`;
                    speedBoostEl.style.display = 'block';
                    this.pigeon.speed = CONFIG.PIGEON_SPEED * 1.8;
                } else {
                    speedBoostEl.style.display = 'none';
                    this.pigeon.speed = CONFIG.PIGEON_SPEED;
                }

                // Update cats
                this.cats.forEach(cat => {
                    if (cat.climbingTree) {
                        if (this.pigeon.onTree !== cat.climbingTree) {
                            // Pigeon left, climb down
                            cat.climbProgress -= 0.01;
                            if (cat.climbProgress <= 0) {
                                cat.climbingTree.climbingCat = null;
                                cat.climbingTree = null;
                                cat.climbProgress = 0;
                            }
                        } else {
                            cat.climbProgress += 0.005;
                            if (cat.climbProgress >= 1) {
                                // Cat caught pigeon on tree!
                                this.end();
                                return;
                            }
                        }
                        return;
                    }

                    // Update direction toward pigeon
                    const dx = this.pigeon.x - cat.x;
                    const dy = this.pigeon.y - cat.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 0) {
                        cat.dirX = dx / len;
                        cat.dirY = dy / len;
                        cat.direction = dx > 0 ? 1 : -1;
                    }

                    cat.x += cat.dirX * cat.speed;
                    cat.y += cat.dirY * cat.speed;

                    // Check if cat should climb tree
                    const nearTree = World.getNearestTree(cat.x, cat.y, 25);
                    if (nearTree && this.pigeon.onTree === nearTree && !nearTree.climbingCat) {
                        cat.climbingTree = nearTree;
                        nearTree.climbingCat = cat;
                        cat.climbProgress = 0;
                        cat.x = nearTree.x;
                        cat.y = nearTree.y;
                    }
                });

                // Remove far away cats
                this.cats = this.cats.filter(cat => {
                    if (cat.climbingTree) return true;
                    return distance(cat.x, cat.y, this.pigeon.x, this.pigeon.y) < CONFIG.DESPAWN_RADIUS;
                });

                // Check breadcrumb collection
                if (!this.pigeon.onTree) {
                    this.breadcrumbs = this.breadcrumbs.filter(crumb => {
                        const dist = distance(this.pigeon.x, this.pigeon.y, crumb.x, crumb.y);
                        if (dist < 25) {
                            this.score += 10;
                            document.getElementById('score').textContent = this.score;
                            return false;
                        }
                        // Remove far breadcrumbs
                        if (dist > CONFIG.DESPAWN_RADIUS) return false;
                        return true;
                    });

                    // Check chest collection
                    this.chests = this.chests.filter(chest => {
                        const dist = distance(this.pigeon.x, this.pigeon.y, chest.x, chest.y);
                        if (dist < 35) {
                            // Activate speed boost for 20 seconds
                            this.pigeon.speedBoostEnd = timestamp + 20000;
                            this.score += 50;
                            document.getElementById('score').textContent = this.score;
                            return false;
                        }
                        // Remove far chests
                        if (dist > CONFIG.DESPAWN_RADIUS) return false;
                        return true;
                    });
                }

                // Check cat collision
                if (!this.pigeon.isJumping && !this.pigeon.onTree) {
                    for (const cat of this.cats) {
                        if (cat.climbingTree) continue;
                        const dist = distance(this.pigeon.x, this.pigeon.y, cat.x, cat.y);
                        if (dist < 35) {
                            this.end();
                            return;
                        }
                    }
                }
            },

            render() {
                // Camera centered on pigeon
                const camX = this.pigeon.x - CONFIG.CANVAS_WIDTH / 2;
                const camY = this.pigeon.y - CONFIG.CANVAS_HEIGHT / 2;

                Renderer.clear();
                Renderer.drawGround(camX, camY);

                // Collect all entities for depth sorting
                const entities = [];

                // Trees in view
                const trees = World.getTreesInView(camX, camY, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                trees.forEach(tree => {
                    entities.push({
                        type: 'tree',
                        y: tree.y,
                        data: tree
                    });
                });

                // Breadcrumbs
                this.breadcrumbs.forEach(crumb => {
                    entities.push({
                        type: 'breadcrumb',
                        y: crumb.y,
                        data: crumb
                    });
                });

                // Chests
                this.chests.forEach(chest => {
                    entities.push({
                        type: 'chest',
                        y: chest.y,
                        data: chest
                    });
                });

                // Cats (not climbing)
                this.cats.forEach(cat => {
                    if (!cat.climbingTree) {
                        entities.push({
                            type: 'cat',
                            y: cat.y,
                            data: cat
                        });
                    }
                });

                // Pigeon (if not on tree)
                if (!this.pigeon.onTree) {
                    entities.push({
                        type: 'pigeon',
                        y: this.pigeon.y,
                        data: this.pigeon
                    });
                }

                // Sort by Y for proper overlap
                entities.sort((a, b) => a.y - b.y);

                // Draw entities
                entities.forEach(entity => {
                    const screen = Renderer.worldToScreen(entity.data.x, entity.data.y, camX, camY);

                    switch (entity.type) {
                        case 'tree':
                            const tree = entity.data;
                            const hasPigeon = this.pigeon.onTree === tree;
                            const hasCat = tree.climbingCat !== null;
                            Renderer.drawTree(screen.x, screen.y, hasPigeon, hasCat);
                            break;
                        case 'breadcrumb':
                            Renderer.drawBreadcrumb(screen.x, screen.y);
                            break;
                        case 'chest':
                            Renderer.drawChest(screen.x, screen.y);
                            break;
                        case 'cat':
                            Renderer.drawCat(screen.x, screen.y, entity.data.direction);
                            break;
                        case 'pigeon':
                            Renderer.drawPigeon(screen.x, screen.y, entity.data.direction, entity.data.isJumping);
                            break;
                    }
                });
            },

            loop(timestamp) {
                if (!this.running) return;

                this.update(timestamp);
                this.render();

                requestAnimationFrame((t) => this.loop(t));
            },

            end() {
                this.running = false;

                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('pigeonHighScore', this.highScore);
                    document.getElementById('highScore').textContent = this.highScore;
                }

                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('jumpIndicator').style.display = 'none';
            }
        };

        window.addEventListener('load', () => Game.init());
    </script>
</body>
</html>
